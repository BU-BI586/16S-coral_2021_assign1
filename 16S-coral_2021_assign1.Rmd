---
title: "Grey Patch Disease in Coral and 16S Analysis of Bacteria"
author: "Susritha Kopparapu, Isabel Novick, Corinne Vietorisz"
date: "2/28/2021"
output:
  html_document: default
  word_document: default
---
## Introduction

Coral reefs are increasingly threatened by climate change, thus the need to identify the diversity of the microbial communities of coral before they die off is becoming more urgent in order to understand the roles their microbial communities play in coral health. Microbial communities may affect host coral fitness, and coral disease may influence the integrity of their microbiome, exacerbating the negative effects. We sought to examine how coral microbial communities change after outbreaks of grey-patch disease. 

Our data is from Sweet et al. (2019), "Compositional homogeneity in the pathobiome of a new, slow-spreading coral disease." We identified and examined the bacterial communities on healthy and diseased corals using 16S sequencing and DNA barcoding. A reanalysis of the Sweet et al. (2019) data was performed using the dada2 pipeline in R followed by the assigning of microbial taxonomy with the Silva 16S database. We found that diseased colonies have a higher abundance of cyanobacteria than healthy colonies, in accordance with the findings of Sweet et al (2019). We additionally found that healthy colonies had higher abundances of gammaproteobacteria compared to diseased colonies. 


## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### R Version
R version 4.0.2 was used for this analysis. 

#### Packages
The following packages were used to clean, analyze, and visualize data. Packages were installed with [Bioconductor](https://bioconductor.org/biocLite.R) version 3.12 using the vegan package. 
```{r, message=FALSE}
library(dada2);         #Version 1.18.0
library(ShortRead);     #Version 1.48.0
library(ggplot2);       #Version 3.3.3
library(phyloseq);      #Version 1.34.0
```

```{r, echo=FALSE, eval=FALSE}
packageVersion("dada2"); citation("dada2")
packageVersion("ShortRead")
packageVersion("ggplot2")
packageVersion("phyloseq")
```

#### Data Retrieval
[Sweet et. al 2019](https://microbiomejournal.biomedcentral.com/articles/10.1186/s40168-019-0759-6) collected samples from healthy and diseased *Porites lobata*, as well as the water column of the Luminao reef flat in Guam (in 2016). Their data that was reanalyzed here was retrieved from [NCBI](https://www.ncbi.nlm.nih.gov/sra?LinkName=bioproject_sra_all&from_uid=448821).

Samples diseased 13, healthy 11, healthy 4, diseased 14, water column 2 were selected. All files in the directory were put in the variable fns. 
```{r, results=FALSE}
path <- "/projectnb/bi594/skoppara/Assignment1"
fns <- list.files(path)
fns
```

## Trimming and Filtering Data
Filter through all the files and find only the fastq files. Sort them so that the reads are in the same order. 
```{r}
fastqs <- fns[grepl(".fastq$", fns)]
fastqs <- sort(fastqs) 
fastqs
```

Split and store each of the files names as sample names without the .fastq file extension. Store these in another variable.
```{r}
sample.names <- sapply(strsplit(fastqs, ".fastq"), `[`, 1) 
#sample.names
fnFs <- file.path(path, fastqs)
#fnFs

```

## Sequence Verification
*code adapted from [Nicola Kriefall](https://github.com/Nicfall/moorea_holobiont/blob/master/mr_16S/mr16s.R)*

The forward and reverse primers as defined from the Sweet et. al paper are shown below.
```{r}
FWD <- "TATGGTAATTGTCTCCTACTTRRSGCAGCAG"  
REV <- "AGTCAGTCAGCCGGACTACNVGGGTWTCTAAT"
```

The below function takes in a character vector primer and creates all the orientations of that sequence. The vector is converted to a DNA String object using the Biostrings package. The DNA string object can be used to evaluate the complement of the sequences. All orients are converted back to character vectors upon return. 
```{r}
allOrients <- function(primer) {
  require(Biostrings)
  dna <- DNAString(primer)  
  orients <- c(Forward = dna, Complement = complement(dna), Reverse = reverse(dna), 
               RevComp = reverseComplement(dna))
  return(sapply(orients, toString))  
}
```

The forward and reverse orients are as follows. 
```{r, echo=FALSE}
FWD.orients <- allOrients(FWD)
REV.orients <- allOrients(REV)
FWD.orients
REV.orients
```


```{r, eval=FALSE}
fnFs.filtN <- file.path(path, "filtN", basename(fnFs))
filterAndTrim(fnFs, fnFs.filtN, maxN = 0, multithread = TRUE)
```

The below function takes in a primer sequence and a read. It counts the number of reads in which the primer is found and returns this value. 
```{r, results=FALSE, eval=FALSE}
primerHits <- function(primer, fn) {
  nhits <- vcountPattern(primer, sread(readFastq(fn)), fixed = FALSE)
  return(sum(nhits > 0))
}
primerHits
```

The below tables show that the primers were removed from the sequences already. No left trim is necessary when filtering the actual sequences. 
```{r, eval=FALSE}
rbind(FWD.ForwardReads = sapply(FWD.orients, primerHits, fn = fnFs.filtN[[3]]), 
      FWD.ReverseReads = sapply(FWD.orients, primerHits, fn = fnFs.filtN[[3]]), 
      REV.ForwardReads = sapply(REV.orients, primerHits, fn = fnFs.filtN[[3]]), 
      REV.ReverseReads = sapply(REV.orients, primerHits, fn = fnFs.filtN[[3]]))
```



#### Visualize Raw Data

The quality plot below shows that the quality stays above or at 20 for the whole length of the sequence, however, around 200 quality does start to drop to 20. For this reason, the truncation length was chosen to be 200. 
```{r}
plotQualityProfile(fnFs[c(1,2,3,4,5,6,7,8,9)])
```

A directory is made for the filtered files and filenames using the following code. 
```{r, eval=FALSE}
filt_path <- file.path(path, "trimmed")
if(!file_test("-d", filt_path)) dir.create(filt_path)
filtFs <- file.path(filt_path, paste0(sample.names, "_F_filt.fastq.gz"))
```

The truncation length was defined to 200. No Ns are allowed and expected errors allowed was 1. All other settings were set to the defaults. 
```{r, eval=FALSE}
out <- filterAndTrim(fnFs, filtFs, truncLen= 200,
                     maxN=0, 
                     maxEE=1, 
                     truncQ=2, 
                     rm.phix=TRUE, 
                     compress=TRUE, 
                     multithread=FALSE) 
```

```{r,echo=FALSE, eval=FALSE}
head(out)
```


## Error Rates
```{r,eval=FALSE}
setDadaOpt(MAX_CONSIST=30) #increase number of cycles to allow convergence
errF <- learnErrors(filtFs, multithread=TRUE)
#Maximum cycles was set to 30, but Convergence was found after 4 rounds

#sanity check: visualize estimated error rates
#error rates should decline with increasing qual score
#red line is based on definition of quality score alone
#black line is estimated error rate after convergence
#dots are observed error rate for each quality score

plotErrors(errF, nominalQ=TRUE) 
```


## Dereplicate Reads
```{r,eval=FALSE}
#Dereplication combines all identical sequencing reads into “unique sequences” with a corresponding “abundance”: the number of reads with that unique sequence. 
#Dereplication substantially reduces computation time by eliminating redundant comparisons.
#DADA2 retains a summary of the quality information associated with each unique sequence. The consensus quality profile of a unique sequence is the average of the positional qualities from the dereplicated reads. These quality profiles inform the error model of the subsequent denoising step, significantly increasing DADA2’s accuracy.
derepFs <- derepFastq(filtFs, verbose=TRUE)
# Name the derep-class objects by the sample names
names(derepFs) <- sample.names
```


## Infer Sequence Variants
Band size 16 for 16S
```{r,eval=FALSE}
#Must change some of the DADA options b/c original program optomized for ribosomal data, not ITS - from github, "We currently recommend BAND_SIZE=32 for ITS data." leave as default for 16S/18S
setDadaOpt(BAND_SIZE=16)
dadaFs <- dada(derepFs, err=errF, multithread=TRUE)

#now, look at the dada class objects by sample
#will tell how many 'real' variants in unique input seqs
#By default, the dada function processes each sample independently, but pooled processing is available with pool=TRUE and that may give better results for low sampling depths at the cost of increased computation time. See our discussion about pooling samples for sample inference. 
dadaFs[[1]]
dadaFs[[5]]

#construct sequence table
seqtab <- makeSequenceTable(dadaFs)
head(seqtab)
```


## Remove Chimeras
```{r,eval=FALSE}
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)
# Identified 1 bimeras out of 117 input sequences.

sum(seqtab.nochim)/sum(seqtab)
#The fraction of chimeras varies based on factors including experimental procedures and sample complexity, 
#Most of your reads should remain after chimera removal (it is not uncommon for a majority of sequence variants to be removed though)
#For our sample, this ratio was 0.9998201, there was only 1 bimera

write.csv(seqtab,file="16s_seqtab.csv")
write.csv(seqtab.nochim,file="16s_nochim.csv")
```


## Track Read Stats
```{r,eval=FALSE}
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaFs, getN), rowSums(seqtab), rowSums(seqtab.nochim))
colnames(track) <- c("input", "filtered", "denoised", "merged", "tabled", "nonchim")
rownames(track) <- sample.names
head(track)
tail(track)

write.csv(track,file="ReadFilterStats_AllData_final.csv",row.names=TRUE,quote=FALSE)

```


## Assign Taxonomy


To assign each sequence its taxa, we compare the sequences to a reference database containing 16S sequences and corresponding taxonimic information for each sequence. We chose the Silva database because it contains a comprehensive library of 16S sequences and is specifically formatted for Dada2.

*Citation:* 
Michael R. McLaren. (2020). Silva SSU taxonomic training data formatted for DADA2 (Silva version 138) (Version 2) [Data set]. Zenodo. http://doi.org/10.5281/zenodo.3986799

First, we classify our sequences according to our reference database with the `assignTaxonomy` function. This assigns taxonomic classifications to each sequence in each sample up to the Genus level.
```{r, eval=FALSE}
taxa <- assignTaxonomy(seqtab.nochim, "/projectnb/bi594/skoppara/Assignment1/silva_nr99_v138_train_set.fa", minBoot = 50, multithread=TRUE, tryRC=TRUE)

```

Then, we add species-level annotation to the taxonomic table with the `addSpecies` function.
```{r, eval=FALSE}
taxa <- addSpecies(taxa, "/projectnb/bi594/skoppara/Assignment1/silva_species_assignment_v138.fa.gz")
```


We next generate a .csv file to save the taxonomic table.
```{r, eval=FALSE}
write.csv(taxa, file="taxa.csv",row.name=TRUE,quote=FALSE)
unname(head(taxa, 30))
unname(taxa)
```


## Visualize Data

```{r,echo=FALSE}
setwd("/projectnb/bi594/skoppara/Assignment1/")

```

Let's read in our sequence table, associated taxa list, and associated metadata.
```{r}
seqtab.nochim <- readRDS("final_seqtab_nochim.rds")
taxa <- readRDS("final_taxa_blastCorrected.rds")
samdf<-read.csv("variabletable.csv")
rownames(samdf) <- samdf$sample
```

Here, we make a phyloseq object with the OTU table, sample data, and taxonomy table. 
```{r,eval=TRUE}
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxa))
ps
```

We replace the sequences with shorter names. 
```{r, eval=FALSE}
ids<-taxa_names(ps)
ids <- paste0("sq",seq(1, length(colnames(seqtab.nochim))))
colnames(seqtab.nochim) <- ids

```

We create a phyloseq object with just the top 90 taxa.
```{r}
top90 <- names(sort(taxa_sums(ps), decreasing=TRUE))[1:90]
ps.top90 <- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top90 <- prune_taxa(top90, ps.top90)
ps.top90
```


Now, we turn the phyloseq object containing our top 90 taxa into a datatable that will allow us to create graphics in ggplot. With this datatable, we make a .csv file for the phyloseq data. This contains the abundances of each individual in each sample by Class. 
```{r}
psz <- psmelt(ps.top90)
write.csv(psz, file="Phyloseqoutputfinal.csv")
```

Now, we make bar plots representing the abundances of the 90 most abundant taxa by sample, separated by Class.
```{r, fig.width=10, fig.height = 8, fig.cap="**Figure 1.** Abundances of the 90 most abundant bacterial taxa by sample."}
p <- ggplot(psz, aes(x = Sample, y=Abundance, fill=Class))
p + geom_bar(stat="identity", colour="black") +
  scale_x_discrete(labels=c('Diseased1', 'Healthy1', "Healthy2", "Diseased2", "Water column"))
```
Note that the diseased samples have more cyanobacteria than the healthy samples, and the healthy samples have more gammaproteobacteria than the diseased samples. Here, we have also included a sample from the water column as a reference to see what taxa are already present in the water.  


To plot counts rather than abundances, we create bar plots of the counts of all the individuals found in each Class by sample.
```{r, fig.width=10, fig.height = 8, fig.cap="**Figure 2.** Counts of all bacterial taxa by sample"}
p2<- plot_bar(ps, x = "Sample", fill= "Class")
p2<- p2 + scale_x_discrete(labels=c('Diseased1', 'Healthy1', "Healthy2", "Diseased2", "Water column"))
p2
```

To more clearly see how bacterial communities vary between healthy and diseased corals, we combine the healthy and diseased samples to plot taxa abundances by sample type. 
```{r, fig.width=10, fig.height = 8, fig.cap="**Figure 3.** Bacterial taxa differ between healthy corals, diseased corals, and the water column."}
p3 <- ggplot(psz, aes(x = type, y=Abundance, fill=Class))
p3 + geom_bar(stat="identity", colour="black") +
  labs(x="Sample type") +
  scale_x_discrete(labels=c('Diseased', 'Healthy', "Water column"))

```


## Conclusion
Bacterial communities differed considerably between individual samples, with much greater bacterial abundance and diversity in coral-associated samples than the water column. We found that diseased colonies have a higher abundance of cyanobacteria than healthy colonies, in accordance with the findings of Sweet et al (2019). We additionally found that healthy colonies had higher abundances of gammaproteobacteria compared to diseased colonies. Overall, these results show that coral-associated bacterial communities differ between healthy and diseased corals. 
